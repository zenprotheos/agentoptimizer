---
alwaysApply: true
---
### Global Rule ‚Äî Windows 11 Agent Command Execution (Refined)

**Applies To:** Windows 11 only
**Goal:** Run commands reliably, avoid hangs, and remove flakiness when Cursor operates agents

#### Key Enhancements

| Issue                                                                         | Improvement                              | Evidence                                     |
| ----------------------------------------------------------------------------- | ---------------------------------------- | -------------------------------------------- |
| `.UseShellExecute = false` required for redirected output to work             | Now explicit in the template             | ([Microsoft Learn][1], [Chromium Issues][2]) |
| `--headless=old` being removed ‚Äî use `--headless` or `--headless=new` instead | Updated in headless mode recommendations | ([Chrome for Developers][3], [Selenium][4])  |

---

#### 1) Launch Syntax (PowerShell + ExecutionPolicy)

```powershell
powershell.exe -NoProfile -ExecutionPolicy Bypass -Command "& { $ErrorActionPreference='Stop'; <YOUR COMMAND> }"
```

#### 2) Pre-flight Validation

```powershell
$exe = 'C:\Path\To\tool.exe'
if (!(Test-Path $exe)) { throw "Missing executable: $exe" }
Set-Location 'C:\Path\To\WorkingDir'  # ensure accurate context
```

#### 3) Control Flow & Bounded Retries

```powershell
function Invoke-WithTimeout {
  param([ScriptBlock]$Script, [int]$TimeoutSec = 60)
  $job = Start-Job -ScriptBlock $Script
  if (Wait-Job $job -Timeout $TimeoutSec) {
    Receive-Job $job
  } else {
    Stop-Job $job -Force
    throw "Command timed out after $TimeoutSec s"
  }
}
$tries=0; $max=3
while ($true) {
  try {
    Invoke-WithTimeout -TimeoutSec 90 -Script { & 'C:\...\.exe' 'args' }
    break
  } catch {
    $tries++
    if ($tries -ge $max) { throw $_ }
    Start-Sleep -Seconds ([math]::Pow(2,$tries))
  }
}
```

#### 4) Redirected Output with UseShellExecute=false

```powershell
$psi = New-Object System.Diagnostics.ProcessStartInfo
$psi.FileName            = 'C:\Program Files\nodejs\node.exe'
$psi.Arguments           = 'cli.js --task build'
$psi.UseShellExecute     = $false         # REQUIRED for redirection
$psi.RedirectStandardOutput = $true
$psi.RedirectStandardError  = $true
$p = [System.Diagnostics.Process]::Start($psi)
$p.WaitForExit(90000) | Out-Null
...
```

Make sure to include `UseShellExecute = $false`; otherwise redirection fails silently. ([CodingTechRoom][5])

#### 5) Headless Mode Modernization

Use:

```
--headless
```

or explicitly (`--headless=new`)
***Avoid** `--headless=old` as it's deprecated and being removed.*
Chromium forum confirms this update: ([Chrome for Developers][3])

---

#### 6) Critical Timeout Requirements

**ALL COMMANDS MUST HAVE TIMEOUTS** as a mandatory failsafe against Windows stalling/hanging:

```powershell
# For PowerShell jobs
$job = Start-Job -ScriptBlock $Script
if (Wait-Job $job -Timeout 60) { Receive-Job $job } else { Stop-Job $job -Force; throw "Timeout" }

# For Process.Start()
$p = [System.Diagnostics.Process]::Start($psi)
if (!$p.WaitForExit(60000)) { $p.Kill(); throw "Process timeout" }

# For web requests
Invoke-WebRequest -Uri $url -TimeoutSec 30

# Default timeout recommendations:
# - Simple commands: 10-30 seconds
# - MCP server startup: 30 seconds  
# - Heavy operations: 90 seconds max
```

---

### Windows 11 MCP Troubleshooting References

When encountering MCP-related issues, refer to these comprehensive guides:

| Guide | Purpose | When to Use |
|-------|---------|-------------|
| **app/guides/cursor-windows/cursor_windows11_mcp_setup.md** | Core setup for MCP servers on Windows 11 | Initial MCP configuration, transport selection (SSE vs StdIO), global config setup |
| **app/guides/cursor-windows/cursor_windows11_mcp_autocheck_guide.md** | Automated verification script for MCP environments | Validating paths, detecting missing runtimes, converting to stable absolute paths |
| **app/guides/cursor-windows/cursor_windows11_mcp_troubleshooting.md** | Comprehensive troubleshooting for MCP issues | Red dots, server connection failures, hangs, configuration errors, diagnostic workflows |

**Common MCP Issues Solved:**
- StdIO servers spawning flaky shells ‚Üí Use absolute paths + proper timeouts
- Python Store alias hijacking ‚Üí Disable alias, use absolute python.exe paths  
- npx causing Windows hangs ‚Üí Install globally, reference direct paths
- Buffer hangs on large output ‚Üí Prefer SSE transport when available
- Missing Chrome/Node/Python paths ‚Üí Auto-detect with verification script

---

#### 7) Temporary File Management (NEW - Windows Agent Specific)

**CRITICAL:** All temporary files MUST follow proper workspace organization:

```powershell
# CORRECT: Task-specific temp files
New-Item -Path "tasks\YYYY-MM-DD_TaskName\tests\temp_script.py" -ItemType File

# CORRECT: Global temp files (non-task specific)  
New-Item -Path "temp\test_script.py" -ItemType File

# WRONG: Root level temp files (FORBIDDEN)
New-Item -Path "test_script.py" -ItemType File  # ‚ùå NEVER DO THIS
```

**Windows Agent Temp File Protocol:**
1. **Task-Specific**: Use `tasks\[TaskName]\tests\` for task-related temp files
2. **Global**: Use `temp\` folder for non-task specific temp files
3. **Cleanup**: ALWAYS delete temp files after use
4. **Root Level**: NEVER create temp files at project root

**Complex Command Workaround:**
- **Issue**: Complex PowerShell escaping with embedded Python causes stalls
- **Solution**: Create temp Python files instead of inline commands
- **Pattern**: Use temporary scripts in proper workspace folders
- **Cleanup**: Delete temp files immediately after execution

```powershell
# Create temp script in proper location
$tempScript = "tasks\2025-08-24_TaskName\tests\temp_test.py"
Set-Content -Path $tempScript -Value "import os; print('test')"

# Execute with timeout
$job = Start-Job -ScriptBlock { python $using:tempScript }
if (Wait-Job $job -Timeout 30) { 
    Receive-Job $job 
} else { 
    Stop-Job $job -Force; throw "Timeout" 
}

# MANDATORY: Clean up temp file
Remove-Item $tempScript -Force
```

---

## üö® ANTI-STALL PROTOCOL üö®

**CRITICAL**: Prevent cursor agent stalls that require manual Ctrl+Enter intervention.

### ‚úÖ WORKING SOLUTION: Use Temp Files for Complex Operations
```powershell
# STEP 1: Create temp script file
$tempScript = "tasks/YYYY-MM-DD_TaskName/tests/temp_$(Get-Random).ps1"
Set-Content -Path $tempScript -Value @"
`$job = Start-Job { <YOUR_COMMAND> }
if (Wait-Job `$job -Timeout <TIMEOUT_SECONDS>) {
    Write-Host "COMPLETED"
    Receive-Job `$job
} else {
    Write-Host "AUTO-RECOVERY: Timeout - continuing"
    Stop-Job `$job
}
Remove-Job `$job -Force
"@

# STEP 2: Execute with timeout protection
powershell.exe -ExecutionPolicy Bypass -File $tempScript

# STEP 3: Clean up
Remove-Item $tempScript -Force
```

### ‚ö†Ô∏è AVOID: Long Inline Commands (Cause Race Condition Stalls)
```powershell
# ‚ùå NEVER: Long commands cause parsing stalls
try { if (Wait-Job $job -Timeout 30) { ... } } finally { ... }

# ‚úÖ ALWAYS: Use temp files for complex operations
```

### Timeout Requirements by Command Type:
- **Simple Commands**: 30 seconds | **MCP Operations**: 60 seconds
- **Heavy Operations**: 90 seconds | **Network Operations**: 45 seconds

### üîß For Simple Commands: Keep Under 50 Characters
```powershell
# ‚úÖ SAFE: Short commands work reliably
Write-Host "Status"; Get-Date; Clear-Host

# ‚ùå RISKY: Long commands cause stalls  
Write-Host "Very long command with lots of parameters and complex syntax"
```

### üóÇÔ∏è Directory Creation: Use Simple mkdir Commands
```powershell
# ‚úÖ SAFE: Simple mkdir commands work reliably
mkdir "tasks\2025-08-25_TaskName\mock_examples\session_examples"

# ‚ùå CAUSES STALLS: Complex New-Item commands with long paths
New-Item -Path "tasks\2025-08-25_TaskName\mock_examples\session_examples" -ItemType Directory -Force

# ‚úÖ ALTERNATIVE: Break into shorter commands if needed
mkdir "tasks\2025-08-25_TaskName\mock_examples"
mkdir "tasks\2025-08-25_TaskName\mock_examples\session_examples"
```

**Directory Creation Stall Pattern:**
- **Issue**: Complex `New-Item` commands with long paths cause parsing stalls
- **Root Cause**: PowerShell parameter parsing overhead with complex syntax
- **Solution**: Use simple `mkdir` command instead of `New-Item -Path ... -ItemType Directory`
- **Evidence**: User reported stalls resolved by switching to simple mkdir syntax

### üîÑ BUFFER RESET PROTOCOL: Prevent Stall Accumulation

**CRITICAL DISCOVERY**: Non-terminal tool calls reset command buffer state and prevent stalls!

#### ‚úÖ WORKING RESET ACTIONS (Use Every 3-5 Commands):
```python
# MCP oneshot tools that reset terminal buffer state:
mcp_oneshot_list_tools()              # Tool listing resets buffer
fetch_rules(["rule-name"])             # Rule fetch resets buffer  
read_file("file.md", limit=3)         # File read resets buffer
list_dir(".", ignore_globs=["*.tmp"])  # Directory listing resets buffer
codebase_search("simple query", [])   # Search resets buffer
```

#### üéØ OPTIMAL WORKFLOW PATTERN:
```
Command 1 ‚Üí Command 2 ‚Üí Command 3 ‚Üí **MCP RESET** ‚Üí Command 4 ‚Üí Command 5 ‚Üí **MCP RESET**
```

#### üìù IMPLEMENTATION RULE:
**MANDATORY**: After every 3-5 terminal commands, use an MCP oneshot tool call to reset buffer state and prevent stall accumulation. MCP tools are preferred as they don't consume Cursor Agent tool calls.

```python
# Example implementation:
run_terminal_cmd("command1")
run_terminal_cmd("command2") 
run_terminal_cmd("command3")
# MCP RESET: Prevent stall accumulation (doesn't count against tool limits)
mcp_oneshot_list_tools()  
run_terminal_cmd("command4")
run_terminal_cmd("command5")
# MCP RESET: Prevent stall accumulation
fetch_rules(["coding-tasks"])
```

### Summary of Rule Enhancements

* **Enforced** absolute executable use
* **Guaranteed** redirected I/O via `.UseShellExecute=false`
* **Modern headless mode**, avoiding deprecated flags
* **Mandatory timeout protection** against Windows stalling
* **Complete anti-stall protocol** with temp files and buffer resets
* **MCP-powered buffer reset** using oneshot tools (no tool call limits)
* **Proper temp file management** in organized workspace structure
* **Complex command workarounds** using temporary scripts
* **MCP-aware troubleshooting** with comprehensive documentation
* **Solid error handling**, timeout control, and retries
* **Clean, reproducible behavior** on Windows agent runs

