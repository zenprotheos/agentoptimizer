---
alwaysApply: true
---

# üö® MANDATORY COMPLETION PROTOCOL üö®
**BEFORE RESPONDING "TASK COMPLETE" YOU MUST:**
1. ‚úÖ **PASS ALL TESTS** - Automated tests must return exit code 0
2. ‚úÖ **GIT COMMIT & PUSH** - All changes committed to GitHub with detailed message
3. ‚úÖ **RULES COMPLIANCE CHECK** - Review ALL coding-tasks steps for compliance
4. ‚úÖ **EXPLICITLY STATE** - "I have completed Steps 3, 4, and 6 of the coding-tasks SOP"

**‚ùå FAILURE TO COMPLETE ALL 4 ITEMS = INCOMPLETE TASK**

---

## Step 1 - Task Workspace
Create a timestamped task folder under `/tasks/` using the standardized date tool:

**Get Current Date**: `powershell.exe -ExecutionPolicy Bypass -File tools/date-current.ps1 taskFolder` ‚Üí `2025-08-25`

```
tasks/YYYY-MM-DD_[TaskName]/
‚îú‚îÄ‚îÄ MASTER_Architecture_UMLs_[TaskName].md
‚îú‚îÄ‚îÄ implementation-plan_[TaskName].md
‚îú‚îÄ‚îÄ development-progress-tracker_[TaskName].md
‚îú‚îÄ‚îÄ troubleshooting_[TaskName].md
‚îú‚îÄ‚îÄ completion-summary_[TaskName].md
‚îú‚îÄ‚îÄ subtasks/
‚îÇ   ‚îú‚îÄ‚îÄ 01_[subtask_name].md
‚îÇ   ‚îú‚îÄ‚îÄ 02_[subtask_name].md
‚îÇ   ‚îî‚îÄ‚îÄ ... (individual tracking docs)
‚îî‚îÄ‚îÄ tests/
```

Notes:
- Include proper front-matter in every `.md` file (use `powershell.exe -ExecutionPolicy Bypass -File tools/date-current.ps1 iso` for timestamps)
- For diagrams, follow your team Mermaid standards (`C:\Users\CSJin\Jininja Projects\AI Projects\main_oneshot\oneshot\.cursor\rules\mermaid-rule.mdc`)
- **Subtasks folder**: Break complex tasks into manageable pieces with individual tracking documents
  - Each subtask should have clear scope, dependencies, progress tracking, and troubleshooting notes
  - Use numbered prefixes (01_, 02_) for logical task ordering
  - Include status tracking, effort estimates, and completion criteria
  - **EXECUTE IMMEDIATELY**: After creating subtask documentation, begin implementation work on the subtasks

### Step 2: Comprehensive UML Documentation (IMMEDIATELY after creating MASTER_Architecture_UMLs_[TaskName].md)
**IMMEDIATELY after creating** `MASTER_Architecture_UMLs_[TaskName].md`, update it with:
- **Comprehensive UML diagrams** showing ALL system interactions
- **Multiple root cause analysis** - never stop at first issue found
- **Race condition mapping** - identify ALL timing dependencies
- **Data flow analysis** - trace complete data lifecycle
- **State management audit** - map ALL state changes and conflicts

### Step 3: üß™ MANDATORY AUTOMATED TESTING (REQUIRED)
**‚õî HARD STOP: Cannot mark task complete without passing tests**

**IMMEDIATE ACTION REQUIRED:**
- Create test script in `tasks/YYYY-MM-DD_[TaskName]/tests/`
- Execute: Test must return exit code 0 (success)
- If exit code ‚â† 0: Fix issues, re-test until passing
- **CHECKPOINT**: Only proceed after tests pass

### Step 4: üîÑ MANDATORY GIT COMMIT & PUSH (REQUIRED)
**‚õî HARD STOP: Cannot complete task without Git commit & push**

**IMMEDIATE ACTION SEQUENCE:**
1. `git add -A` - Stage all changes
2. `git commit -m "[detailed message]"` - Use template below
3. `git push origin HEAD` - Push to GitHub
4. **VERIFY**: Confirm push successful (no errors)
5. **CHECKPOINT**: Git workflow complete

#### Automatic Git Workflow Requirements
1. **Stage All Changes**: Add all modified files, documentation, tests, and artifacts
2. **Detailed Commit Message**: Create comprehensive commit messages following the template below
3. **Automatic Push**: Push commits to GitHub immediately after successful commit
4. **Branch Management**: Ensure commits are on the correct feature/task branch

#### Commit Message Template
```
[TASK] TaskName - SubtaskName: Brief Description

## Changes Made:
- Specific change 1 with file references
- Specific change 2 with implementation details
- Documentation updates and locations
- Test implementations and validation results

## Testing Status:
- ‚úÖ All automated tests passed
- ‚úÖ Integration tests validated
- ‚úÖ Cross-platform compatibility verified
- ‚úÖ Error handling tested

## Architecture Impact:
- UML diagrams updated: [file references]
- System interactions documented
- Dependencies and conflicts resolved

## Completion Status:
- Subtask: [COMPLETED/IN-PROGRESS]
- Parent Task: [COMPLETED/IN-PROGRESS]
- Next Steps: [Brief description if applicable]

Generated: $(node tools/date-current.cjs iso)
```

#### Git Command Execution Protocol
```powershell
# Stage all changes with timeout protection
$job = Start-Job -ScriptBlock { git add -A }
if (Wait-Job $job -Timeout 30) {
    Receive-Job $job; Remove-Job $job
} else {
    Stop-Job $job -Force; Remove-Job $job
    Write-Host "‚ö†Ô∏è Git add timeout - manual verification required"
}

# Commit with detailed message
$commitMsg = "Generated detailed commit message here..."
$job = Start-Job -ScriptBlock { git commit -m $using:commitMsg }
if (Wait-Job $job -Timeout 45) {
    Receive-Job $job; Remove-Job $job
} else {
    Stop-Job $job -Force; Remove-Job $job
    Write-Host "‚ö†Ô∏è Git commit timeout - continuing execution"
}

# Push to remote with timeout protection
$job = Start-Job -ScriptBlock { git push origin HEAD }
if (Wait-Job $job -Timeout 60) {
    Receive-Job $job; Remove-Job $job
    Write-Host "‚úÖ Successfully pushed to GitHub"
} else {
    Stop-Job $job -Force; Remove-Job $job
    Write-Host "‚ö†Ô∏è Git push timeout - may need manual retry"
}
```

#### Commit Frequency Requirements
- **Subtask Completion**: MANDATORY commit after each subtask finishes
- **Task Milestone**: MANDATORY commit after major task milestones
- **Testing Success**: MANDATORY commit after all tests pass
- **Documentation Updates**: MANDATORY commit after architecture/UML updates
- **Error Resolution**: MANDATORY commit after fixing critical issues

#### Commit Quality Standards
- **Descriptive Titles**: Clear, specific titles that explain the change
- **Detailed Bodies**: Comprehensive change descriptions with file references
- **Status Tracking**: Clear indication of completion status and next steps
- **Timestamp Metadata**: Include generation timestamp for tracking
- **Testing Evidence**: Document all testing validations in commit message

#### Branch Strategy Integration
- **Feature Branches**: Use task-specific branches for larger changes
- **Commit Frequency**: Multiple commits per task for granular tracking
- **Merge Strategy**: Prepare for clean merges to main branch
- **Conflict Resolution**: Address merge conflicts before final push

### Step 5: LESSONS LEARNED & RULE ENHANCEMENT (AFTER COMMIT)
**REQUIRED: After git commit/push, identify lessons learned and propose rule improvements**

#### Lessons Learned Documentation
1. **Document Key Lessons**: Record what was learned during task execution
2. **Identify Pain Points**: Note any processes that caused delays or confusion
3. **Propose Rule Enhancements**: Suggest specific additions to coding-tasks.mdc
4. **Process Improvements**: Recommend changes to prevent future issues
5. **Add to Global Rules**: Include actionable improvements in the coding-tasks rule to help future agents

#### Rule Enhancement Examples
- Workflow improvements discovered during implementation
- Testing patterns that proved especially valuable
- Common pitfalls and how to avoid them
- Tool usage patterns that work best
- Documentation standards that improve efficiency

#### Core Testing Requirements
1. **Create Task-Specific Test Script**: Every implementation task MUST create automated tests
2. **Test All Modified Functionality**: Every changed endpoint, UI component, and flow
3. **Test Existing Functionality**: Ensure changes don't break existing features
4. **Exit Code Validation**: Tests must return exit code 0 (success) or 1 (failure)

#### Testing Tools & Scripts
- **üö® MANDATORY TEST LOCATION üö®**: Create ALL tests in `tasks/YYYY-MM-DD_[TaskName]/tests/` folder ONLY
  - **NEVER create test scripts at project root level**
  - **NEVER create test scripts outside the task folder**
  - **ALWAYS use the task-specific tests/ directory**
  - Example correct path: `tasks/2025-08-24_OneShot_Windows_Compatibility/tests/test_my_feature.py`
  - Example WRONG path: `test_my_feature.py` (root level - FORBIDDEN)

#### Temporary File Management (CRITICAL)
- **üö® TEMP FILE PROTOCOL üö®**: ALL temporary files MUST follow workspace organization
  - **Task-Related Temp Files**: Use `tasks/YYYY-MM-DD_[TaskName]/tests/temp_*.py` 
  - **Global Temp Files**: Use `temp/temp_*.py` for non-task specific files
  - **ROOT LEVEL FORBIDDEN**: NEVER create temp files at project root
  - **MANDATORY CLEANUP**: ALWAYS delete temp files after use
  - **Windows-Specific**: Use temp files to avoid complex PowerShell escaping issues

```python
# CORRECT: Task-specific temp file
temp_file = "tasks/2024-08-25_TaskName/tests/temp_validation.py"
with open(temp_file, 'w') as f:
    f.write("test_code_here")
# Execute test
os.system(f"python {temp_file}")
# MANDATORY: Clean up
os.remove(temp_file)

# WRONG: Root level temp file (FORBIDDEN)
temp_file = "temp_test.py"  # ‚ùå NEVER DO THIS
```
- **Intelligent Test Scripts**: Create logical, comprehensive test scripts that validate actual functionality
  - Test real-world scenarios, not just unit tests
  - Include error handling and edge case validation
  - Test cross-platform compatibility when relevant
  - Validate end-to-end workflows work correctly
  - Include automated pass/fail criteria with meaningful error messages
- **Test File Cleanup**: ALWAYS delete temporary test files created at root level after use
  - Use the task/tests/ folder for ALL permanent test artifacts
  - Clean up any accidental root-level test files immediately
  - Maintain clean project root directory
- **Status Updates**: ALWAYS update subtask/task status and progress AFTER testing validations pass
  - Update status from "Not Started" ‚Üí "In Progress" ‚Üí "Completed" 
  - Document progress in Progress Log with dates, actions, and test results
  - Only mark as "Completed" after all tests pass successfully
  - **MANDATORY**: Execute automatic Git commit & push IMMEDIATELY after marking "Completed"
- **Checkbox Completion**: MANDATORY - tick all relevant checkboxes when subtasks/tasks complete
  - Mark all completed items in Implementation Plan checklists as [x]
  - Update Test Cases checkboxes as tests pass
  - Complete Testing Checklist items as validation succeeds
  - Tick Definition of Done checkboxes when criteria are met
  - Ensure all documentation reflects actual completion status
  - **MANDATORY**: After ticking final completion checkboxes, execute Git commit & push protocol
- **End-to-End Master Test**: After completing individual subtasks, create ONE master test that validates the entire user workflow
  - Test from user perspective, not just individual components
  - Validate complete application functionality, not just micro-level features
  - Ensure the whole system works together even if individual parts pass tests
  - Master test should simulate real user scenarios and catch integration issues
  - **MANDATORY**: After master test passes, execute final Git commit & push for task completion

### Step 6: üìã MANDATORY RULES COMPLIANCE CHECK (REQUIRED)
**‚õî HARD STOP: Cannot complete without full SOP compliance verification**

**IMMEDIATE COMPLIANCE AUDIT:**
1. **Review Step 3**: ‚úÖ Tests passed (exit code 0)?
2. **Review Step 4**: ‚úÖ Git commit & push completed?
3. **Review Step 6**: ‚úÖ This compliance check completed?
4. **EXPLICIT STATEMENT REQUIRED**: "I have completed Steps 3, 4, and 6 of the coding-tasks SOP"
5. **CHECKPOINT**: Full compliance verified

#### Global Rules Review Requirements
1. **Review All Applicable Rules**: After completing ANY task or subtask, review relevant global rules
2. **Verify SOP Compliance**: Ensure all standard operating procedures were followed correctly
3. **Identify Rule Violations**: Check for any deviations from established protocols
4. **Document Compliance Status**: Record rule adherence in completion documentation
5. **Update Global Rules**: Add any discovered improvements or missing procedures

#### Review Process
- **Fetch All Rules**: Use `fetch_rules()` to retrieve relevant rule sets
- **Cross-Reference Actions**: Compare completed work against rule requirements
- **Validate Documentation**: Ensure all required documentation was created/updated
- **Verify Testing**: Confirm testing protocols were followed completely
- **Check Git Workflow**: Validate commit/push procedures were executed correctly

#### Compliance Checklist
- [ ] All required documentation created/updated
- [ ] Testing protocols followed completely
- [ ] Git workflow executed properly
- [ ] Temporary files managed correctly
- [ ] Architecture diagrams updated
- [ ] Lessons learned documented
- [ ] Rule enhancements proposed
- [ ] Next steps identified

#### Rule Violation Protocol
If any rule violations are discovered:
1. **Document Violation**: Record what rule was violated and how
2. **Correct Immediately**: Fix any issues before marking task complete
3. **Update Documentation**: Reflect corrections in task documentation
4. **Propose Rule Enhancement**: Suggest improvements to prevent future violations
5. **Commit Corrections**: Execute git commit/push for any fixes

## üîÑ BUFFER RESET PROTOCOL: Prevent Stall Accumulation

**CRITICAL DISCOVERY**: Non-terminal tool calls reset command buffer state and prevent stalls!

#### ‚úÖ WORKING RESET ACTIONS (Use Every 3-5 Commands):
```python
# MCP oneshot tools that reset terminal buffer state:
mcp_oneshot_list_tools()              # Tool listing resets buffer
fetch_rules(["rule-name"])             # Rule fetch resets buffer  
read_file("file.md", limit=3)         # File read resets buffer
list_dir(".", ignore_globs=["*.tmp"])  # Directory listing resets buffer
codebase_search("simple query", [])   # Search resets buffer
```

#### üéØ OPTIMAL WORKFLOW PATTERN:
```
Command 1 ‚Üí Command 2 ‚Üí Command 3 ‚Üí **MCP RESET** ‚Üí Command 4 ‚Üí Command 5 ‚Üí **MCP RESET**
```

#### üìù IMPLEMENTATION RULE:
**MANDATORY**: After every 3-5 terminal commands, use an MCP oneshot tool call to reset buffer state and prevent stall accumulation. MCP tools are preferred as they don't consume Cursor Agent tool calls.

```python
# Example implementation:
run_terminal_cmd("command1")
run_terminal_cmd("command2") 
run_terminal_cmd("command3")
# MCP RESET: Prevent stall accumulation (doesn't count against tool limits)
mcp_oneshot_list_tools()  
run_terminal_cmd("command4")
run_terminal_cmd("command5")
# MCP RESET: Prevent stall accumulation
fetch_rules(["coding-tasks"])
```

---

# üéØ TASK COMPLETION VERIFICATION CHECKLIST

**BEFORE SAYING "TASK COMPLETE" - VERIFY ALL 4 ITEMS:**

## ‚úÖ Step 3: Testing Complete
- [ ] Created test script in `tasks/YYYY-MM-DD_[TaskName]/tests/`
- [ ] Executed test: Exit code = 0 (success)
- [ ] All functionality validated

## ‚úÖ Step 4: Git Workflow Complete  
- [ ] `git add -A` executed
- [ ] `git commit -m "[detailed message]"` executed
- [ ] `git push origin HEAD` executed
- [ ] Push successful (no errors)

## ‚úÖ Step 6: Compliance Verified
- [ ] Reviewed Steps 3, 4, 6 completion
- [ ] All SOP requirements met
- [ ] Ready to state compliance

## ‚úÖ Required Statement
**MUST INCLUDE IN RESPONSE:**
"I have completed Steps 3, 4, and 6 of the coding-tasks SOP"

**üö® IF ANY ITEM UNCHECKED = TASK INCOMPLETE üö®**