---
alwaysApply: true
---

# üö® MANDATORY COMPLETION PROTOCOL üö®
**BEFORE RESPONDING "TASK COMPLETE" YOU MUST:**
1. ‚úÖ **PASS ALL TESTS** - Automated tests must return exit code 0
2. ‚úÖ **PASS MASTER END-TO-END TEST** - Complete user workflow validation must pass
3. ‚úÖ **UPDATE TASK INDEX** - All workspace indexes reflect current state
4. ‚úÖ **GIT COMMIT & PUSH** - All changes committed to GitHub with detailed message
5. ‚úÖ **RULES COMPLIANCE CHECK** - Review ALL coding-tasks steps for compliance
6. ‚úÖ **EXPLICITLY STATE** - "I have completed Steps 3, 4, 5, 6, and 8 of the coding-tasks SOP"

**‚ùå FAILURE TO COMPLETE ALL 6 ITEMS = INCOMPLETE TASK**

---

## Step 1 - Task Workspace
Create a timestamped task folder under `/tasks/` using the standardized date tool:

**Get Current Date**: `powershell.exe -ExecutionPolicy Bypass -File tools/date-current.ps1 taskFolder` ‚Üí `2025-08-25`

**üö® WINDOWS DATE TOOL PRIORITY üö®**: 
- **PRIMARY**: Always use `powershell.exe -ExecutionPolicy Bypass -File tools/date-current.ps1` on Windows
- **AVOID**: `node tools/date-current.cjs` causes timeout/stall issues on Windows
- **REASON**: PowerShell execution is more reliable and bypasses Node.js hanging problems

```
tasks/YYYY-MM-DD_[TaskName]/
‚îú‚îÄ‚îÄ MASTER_Architecture_UMLs_[TaskName].md
‚îú‚îÄ‚îÄ implementation-plan_[TaskName].md
‚îú‚îÄ‚îÄ development-progress-tracker_[TaskName].md
‚îú‚îÄ‚îÄ troubleshooting_[TaskName].md
‚îú‚îÄ‚îÄ completion-summary_[TaskName].md
‚îú‚îÄ‚îÄ subtasks/
‚îÇ   ‚îú‚îÄ‚îÄ 01_[subtask_name].md
‚îÇ   ‚îú‚îÄ‚îÄ 02_[subtask_name].md
‚îÇ   ‚îî‚îÄ‚îÄ ... (individual tracking docs)
‚îî‚îÄ‚îÄ tests/
```

Notes:
- Include proper front-matter in every `.md` file (use `powershell.exe -ExecutionPolicy Bypass -File tools/date-current.ps1 iso` for timestamps)
- For diagrams, follow your team Mermaid standards (`C:\Users\CSJin\Jininja Projects\AI Projects\main_oneshot\oneshot\.cursor\rules\mermaid-rule.mdc`)
- **üö® MANDATORY INDEX UPDATES**: After ANY document addition, deletion, or significant modification:
  - Update task workspace index (`TASK_WORKSPACE_INDEX.md`) immediately
  - Use existing `session-index-builder.cjs` for large workspaces
  - Ensure cross-references and navigation remain accurate
  - **TIMING**: Update index before proceeding to next step
- **Subtasks folder**: Break complex tasks into manageable pieces with individual tracking documents
  - Each subtask should have clear scope, dependencies, progress tracking, and troubleshooting notes
  - Use numbered prefixes (01_, 02_) for logical task ordering
  - Include status tracking, effort estimates, and completion criteria
  - **EXECUTE IMMEDIATELY**: After creating subtask documentation, begin implementation work on the subtasks

### Step 2: Comprehensive UML Documentation (IMMEDIATELY after creating MASTER_Architecture_UMLs_[TaskName].md)
**IMMEDIATELY after creating** `MASTER_Architecture_UMLs_[TaskName].md`, update it with:
- **Comprehensive UML diagrams** showing ALL system interactions
- **Multiple root cause analysis** - never stop at first issue found
- **Race condition mapping** - identify ALL timing dependencies
- **Data flow analysis** - trace complete data lifecycle
- **State management audit** - map ALL state changes and conflicts

### Step 3: üß™ MANDATORY AUTOMATED TESTING (REQUIRED)
**‚õî HARD STOP: Cannot mark task complete without passing tests**

**IMMEDIATE ACTION REQUIRED:**
- Create test script in `tasks/YYYY-MM-DD_[TaskName]/tests/`
- Execute: Test must return exit code 0 (success)
- If exit code ‚â† 0: Fix issues, re-test until passing
- **CHECKPOINT**: Only proceed after tests pass

### Step 4: üéØ MANDATORY MASTER END-TO-END TEST (REQUIRED)
**‚õî HARD STOP: Cannot complete task without comprehensive user workflow validation**

**CRITICAL: This step is MANDATORY and AUTOMATED - no exceptions**

**IMMEDIATE ACTION REQUIRED:**
1. **Create Master Test Script**: `tasks/YYYY-MM-DD_[TaskName]/tests/master_end_to_end_test.py`
2. **Test Complete User Workflow**: Validate ENTIRE system from user perspective
3. **Execute Master Test**: Must return exit code 0 (success)
4. **Fix Integration Issues**: If exit code ‚â† 0, resolve all integration problems
5. **CHECKPOINT**: Only proceed after master test passes

#### Master Test Requirements
- **üö® MANDATORY AUTOMATION üö®**: This test MUST be created automatically without user prompting
- **User Perspective Testing**: Test complete workflows as an actual user would experience them
- **End-to-End Validation**: Verify entire system functionality, not just individual components
- **Integration Testing**: Ensure all parts work together seamlessly
- **Real-World Scenarios**: Simulate authentic user interactions and use cases
- **Error Handling**: Test edge cases and error conditions in the complete workflow
- **Cross-System Testing**: Validate interactions between different system components
- **Performance Validation**: Ensure acceptable response times for complete workflows

#### Master Test Structure Template
```python
# Master End-to-End Test Template
import sys
import os
# Add comprehensive imports for your system

def test_complete_user_workflow():
    """Test the entire user workflow from start to finish"""
    print("üéØ Starting Master End-to-End Test...")
    
    # Test Step 1: Initial setup/authentication
    # Test Step 2: Core functionality
    # Test Step 3: Data persistence
    # Test Step 4: User interactions
    # Test Step 5: Final validation
    
    print("‚úÖ Master End-to-End Test PASSED")
    return True

def test_error_scenarios():
    """Test error handling in complete workflows"""
    # Test various error conditions
    pass

def test_integration_points():
    """Test all system integration points"""
    # Test component interactions
    pass

if __name__ == "__main__":
    try:
        test_complete_user_workflow()
        test_error_scenarios()
        test_integration_points()
        print("üéâ ALL MASTER TESTS PASSED")
        sys.exit(0)  # Success
    except Exception as e:
        print(f"‚ùå MASTER TEST FAILED: {e}")
        sys.exit(1)  # Failure
```

#### Master Test Execution Protocol
```powershell
# Execute master test with timeout protection
$masterTest = "tasks/YYYY-MM-DD_[TaskName]/tests/master_end_to_end_test.py"
$job = Start-Job -ScriptBlock { python $using:masterTest }
if (Wait-Job $job -Timeout 120) {
    $result = Receive-Job $job
    Write-Host $result
    if ($LASTEXITCODE -eq 0) {
        Write-Host "‚úÖ Master End-to-End Test PASSED"
    } else {
        throw "‚ùå Master End-to-End Test FAILED - Must fix before completion"
    }
} else {
    Stop-Job $job -Force
    throw "‚ùå Master test timeout - Must fix before completion"
}
Remove-Job $job -Force
```

### Step 5: üìã MANDATORY INDEX UPDATES (REQUIRED)
**‚õî HARD STOP: Cannot proceed without updated workspace indexes**

**IMMEDIATE ACTION REQUIRED:**
1. **Update Task Workspace Index**: Ensure `TASK_WORKSPACE_INDEX.md` reflects all changes
2. **Run Session Index Builder**: Use `session-index-builder.cjs` for large workspaces if needed
3. **Verify Cross-References**: All internal links and navigation remain accurate
4. **Update Statistics**: File counts, examples, tools, and status information current
5. **CHECKPOINT**: Index accuracy verified before git operations

#### Index Update Requirements
- **File Changes**: Any document addition, deletion, or major modification
- **Structure Changes**: New directories, reorganized content, renamed files
- **Status Updates**: Progress changes, completion markers, priority shifts
- **Cross-Task Integration**: Links to related tasks, shared resources, dependencies

#### Index Update Protocol
```powershell
# For task workspaces with many files, use automated indexing
$indexBuilder = "tasks/YYYY-MM-DD_[TaskName]/imported_tools/indexing/session-index-builder.cjs"
if (Test-Path $indexBuilder) {
    node $indexBuilder
    Write-Host "‚úÖ Automated index updated"
} else {
    Write-Host "‚ö†Ô∏è Manual index update required - update TASK_WORKSPACE_INDEX.md"
}
```

#### Index Quality Standards
- **Navigation Accuracy**: All links functional and point to correct sections
- **Current Statistics**: File counts, completion status, integration points accurate
- **Clear Structure**: Logical organization with priority-based navigation
- **Cross-References**: Related tasks, dependencies, and shared resources linked
- **Timestamp Updates**: Last updated timestamps reflect current state

### Step 6: üîÑ MANDATORY GIT COMMIT & PUSH (REQUIRED)
**‚õî HARD STOP: Cannot complete task without Git commit & push**

**IMMEDIATE ACTION SEQUENCE:**
1. `git add -A` - Stage all changes
2. `git commit -m "[detailed message]"` - Use template below
3. `git push origin HEAD` - Push to GitHub
4. **VERIFY**: Confirm push successful (no errors)
5. **CHECKPOINT**: Git workflow complete

#### Automatic Git Workflow Requirements
1. **Stage All Changes**: Add all modified files, documentation, tests, and artifacts
2. **Detailed Commit Message**: Create comprehensive commit messages following the template below
3. **Automatic Push**: Push commits to GitHub immediately after successful commit
4. **Branch Management**: Ensure commits are on the correct feature/task branch

#### Commit Message Template
```
[TASK] TaskName - SubtaskName: Brief Description

## Changes Made:
- Specific change 1 with file references
- Specific change 2 with implementation details
- Documentation updates and locations
- Test implementations and validation results

## Testing Status:
- ‚úÖ All unit/component tests passed
- ‚úÖ Master end-to-end test passed
- ‚úÖ Complete user workflow validated
- ‚úÖ Integration tests validated
- ‚úÖ Cross-platform compatibility verified
- ‚úÖ Error handling tested

## Architecture Impact:
- UML diagrams updated: [file references]
- System interactions documented
- Dependencies and conflicts resolved

## Completion Status:
- Subtask: [COMPLETED/IN-PROGRESS]
- Parent Task: [COMPLETED/IN-PROGRESS]
- Next Steps: [Brief description if applicable]

Generated: $(powershell.exe -ExecutionPolicy Bypass -File tools/date-current.ps1 iso)
```

#### Git Command Execution Protocol
```powershell
# Stage all changes with timeout protection
$job = Start-Job -ScriptBlock { git add -A }
if (Wait-Job $job -Timeout 30) {
    Receive-Job $job; Remove-Job $job
} else {
    Stop-Job $job -Force; Remove-Job $job
    Write-Host "‚ö†Ô∏è Git add timeout - manual verification required"
}

# Commit with detailed message
$commitMsg = "Generated detailed commit message here..."
$job = Start-Job -ScriptBlock { git commit -m $using:commitMsg }
if (Wait-Job $job -Timeout 45) {
    Receive-Job $job; Remove-Job $job
} else {
    Stop-Job $job -Force; Remove-Job $job
    Write-Host "‚ö†Ô∏è Git commit timeout - continuing execution"
}

# Push to remote with timeout protection
$job = Start-Job -ScriptBlock { git push origin HEAD }
if (Wait-Job $job -Timeout 60) {
    Receive-Job $job; Remove-Job $job
    Write-Host "‚úÖ Successfully pushed to GitHub"
} else {
    Stop-Job $job -Force; Remove-Job $job
    Write-Host "‚ö†Ô∏è Git push timeout - may need manual retry"
}
```

#### Commit Frequency Requirements
- **Subtask Completion**: MANDATORY commit after each subtask finishes
- **Task Milestone**: MANDATORY commit after major task milestones
- **Testing Success**: MANDATORY commit after all tests pass
- **Documentation Updates**: MANDATORY commit after architecture/UML updates
- **Error Resolution**: MANDATORY commit after fixing critical issues

#### Commit Quality Standards
- **Descriptive Titles**: Clear, specific titles that explain the change
- **Detailed Bodies**: Comprehensive change descriptions with file references
- **Status Tracking**: Clear indication of completion status and next steps
- **Timestamp Metadata**: Include generation timestamp for tracking
- **Testing Evidence**: Document all testing validations in commit message

#### Branch Strategy Integration
- **Feature Branches**: Use task-specific branches for larger changes
- **Commit Frequency**: Multiple commits per task for granular tracking
- **Merge Strategy**: Prepare for clean merges to main branch
- **Conflict Resolution**: Address merge conflicts before final push

### Step 7: LESSONS LEARNED & RULE ENHANCEMENT (AFTER COMMIT)
**REQUIRED: After git commit/push, identify lessons learned and propose rule improvements**

#### Lessons Learned Documentation
1. **Document Key Lessons**: Record what was learned during task execution
2. **Identify Pain Points**: Note any processes that caused delays or confusion
3. **Propose Rule Enhancements**: Suggest specific additions to coding-tasks.mdc
4. **Process Improvements**: Recommend changes to prevent future issues
5. **Add to Global Rules**: Include actionable improvements in the coding-tasks rule to help future agents

#### Rule Enhancement Examples
- Workflow improvements discovered during implementation
- Testing patterns that proved especially valuable
- Common pitfalls and how to avoid them
- Tool usage patterns that work best
- Documentation standards that improve efficiency

#### Core Testing Requirements
1. **Create Task-Specific Test Script**: Every implementation task MUST create automated tests
2. **Test All Modified Functionality**: Every changed endpoint, UI component, and flow
3. **Test Existing Functionality**: Ensure changes don't break existing features
4. **Exit Code Validation**: Tests must return exit code 0 (success) or 1 (failure)

#### Testing Tools & Scripts
- **üö® MANDATORY TEST LOCATION üö®**: Create ALL tests in `tasks/YYYY-MM-DD_[TaskName]/tests/` folder ONLY
  - **NEVER create test scripts at project root level**
  - **NEVER create test scripts outside the task folder**
  - **ALWAYS use the task-specific tests/ directory**
  - Example correct path: `tasks/2025-08-24_OneShot_Windows_Compatibility/tests/test_my_feature.py`
  - Example WRONG path: `test_my_feature.py` (root level - FORBIDDEN)

#### Temporary File Management (CRITICAL)
- **üö® TEMP FILE PROTOCOL üö®**: ALL temporary files MUST follow workspace organization
  - **Task-Related Temp Files**: Use `tasks/YYYY-MM-DD_[TaskName]/tests/temp_*.py` 
  - **Global Temp Files**: Use `temp/temp_*.py` for non-task specific files
  - **ROOT LEVEL FORBIDDEN**: NEVER create temp files at project root
  - **MANDATORY CLEANUP**: ALWAYS delete temp files after use
  - **Windows-Specific**: Use temp files to avoid complex PowerShell escaping issues

```python
# CORRECT: Task-specific temp file
temp_file = "tasks/2024-08-25_TaskName/tests/temp_validation.py"
with open(temp_file, 'w') as f:
    f.write("test_code_here")
# Execute test
os.system(f"python {temp_file}")
# MANDATORY: Clean up
os.remove(temp_file)

# WRONG: Root level temp file (FORBIDDEN)
temp_file = "temp_test.py"  # ‚ùå NEVER DO THIS
```
- **Intelligent Test Scripts**: Create logical, comprehensive test scripts that validate actual functionality
  - Test real-world scenarios, not just unit tests
  - Include error handling and edge case validation
  - Test cross-platform compatibility when relevant
  - Validate end-to-end workflows work correctly
  - Include automated pass/fail criteria with meaningful error messages
- **Test File Cleanup**: ALWAYS delete temporary test files created at root level after use
  - Use the task/tests/ folder for ALL permanent test artifacts
  - Clean up any accidental root-level test files immediately
  - Maintain clean project root directory
- **Status Updates**: ALWAYS update subtask/task status and progress AFTER testing validations pass
  - Update status from "Not Started" ‚Üí "In Progress" ‚Üí "Completed" 
  - Document progress in Progress Log with dates, actions, and test results
  - Only mark as "Completed" after all tests pass successfully
  - **MANDATORY**: Execute automatic Git commit & push IMMEDIATELY after marking "Completed"
- **Checkbox Completion**: MANDATORY - tick all relevant checkboxes when subtasks/tasks complete
  - Mark all completed items in Implementation Plan checklists as [x]
  - Update Test Cases checkboxes as tests pass
  - Complete Testing Checklist items as validation succeeds
  - Tick Definition of Done checkboxes when criteria are met
  - Ensure all documentation reflects actual completion status
  - **MANDATORY**: After ticking final completion checkboxes, execute Git commit & push protocol
- **End-to-End Master Test**: Refer to Step 4 for comprehensive master test requirements
  - **AUTOMATIC CREATION**: Master test is created automatically as part of Step 4
  - **MANDATORY EXECUTION**: Must pass before task can be marked complete
  - **USER WORKFLOW FOCUS**: Tests complete user experience, not just components
  - **INTEGRATION VALIDATION**: Ensures all system parts work together seamlessly

### Step 8: üìã MANDATORY RULES COMPLIANCE CHECK (REQUIRED)
**‚õî HARD STOP: Cannot complete without full SOP compliance verification**

**IMMEDIATE COMPLIANCE AUDIT:**
1. **Review Step 3**: ‚úÖ Unit/component tests passed (exit code 0)?
2. **Review Step 4**: ‚úÖ Master end-to-end test passed (exit code 0)?
3. **Review Step 5**: ‚úÖ Task workspace indexes updated and accurate?
4. **Review Step 6**: ‚úÖ Git commit & push completed?
5. **Review Step 8**: ‚úÖ This compliance check completed?
6. **EXPLICIT STATEMENT REQUIRED**: "I have completed Steps 3, 4, 5, 6, and 8 of the coding-tasks SOP"
7. **CHECKPOINT**: Full compliance verified

#### Global Rules Review Requirements
1. **Review All Applicable Rules**: After completing ANY task or subtask, review relevant global rules
2. **Verify SOP Compliance**: Ensure all standard operating procedures were followed correctly
3. **Identify Rule Violations**: Check for any deviations from established protocols
4. **Document Compliance Status**: Record rule adherence in completion documentation
5. **Update Global Rules**: Add any discovered improvements or missing procedures

#### Review Process
- **Fetch All Rules**: Use `fetch_rules()` to retrieve relevant rule sets
- **Cross-Reference Actions**: Compare completed work against rule requirements
- **Validate Documentation**: Ensure all required documentation was created/updated
- **Verify Testing**: Confirm testing protocols were followed completely
- **Check Git Workflow**: Validate commit/push procedures were executed correctly

#### Compliance Checklist
- [ ] All required documentation created/updated
- [ ] Testing protocols followed completely
- [ ] Git workflow executed properly
- [ ] Temporary files managed correctly
- [ ] Architecture diagrams updated
- [ ] Lessons learned documented
- [ ] Rule enhancements proposed
- [ ] Next steps identified

#### Rule Violation Protocol
If any rule violations are discovered:
1. **Document Violation**: Record what rule was violated and how
2. **Correct Immediately**: Fix any issues before marking task complete
3. **Update Documentation**: Reflect corrections in task documentation
4. **Propose Rule Enhancement**: Suggest improvements to prevent future violations
5. **Commit Corrections**: Execute git commit/push for any fixes

## üîÑ BUFFER RESET PROTOCOL: Prevent Stall Accumulation

**CRITICAL DISCOVERY**: Non-terminal tool calls reset command buffer state and prevent stalls!

#### ‚úÖ WORKING RESET ACTIONS (Use Every 3-5 Commands):
```python
# MCP oneshot tools that reset terminal buffer state:
mcp_oneshot_list_tools()              # Tool listing resets buffer
fetch_rules(["rule-name"])             # Rule fetch resets buffer  
read_file("file.md", limit=3)         # File read resets buffer
list_dir(".", ignore_globs=["*.tmp"])  # Directory listing resets buffer
codebase_search("simple query", [])   # Search resets buffer
```

#### üéØ OPTIMAL WORKFLOW PATTERN:
```
Command 1 ‚Üí Command 2 ‚Üí Command 3 ‚Üí **MCP RESET** ‚Üí Command 4 ‚Üí Command 5 ‚Üí **MCP RESET**
```

#### üìù IMPLEMENTATION RULE:
**MANDATORY**: After every 3-5 terminal commands, use an MCP oneshot tool call to reset buffer state and prevent stall accumulation. MCP tools are preferred as they don't consume Cursor Agent tool calls.

```python
# Example implementation:
run_terminal_cmd("command1")
run_terminal_cmd("command2") 
run_terminal_cmd("command3")
# MCP RESET: Prevent stall accumulation (doesn't count against tool limits)
mcp_oneshot_list_tools()  
run_terminal_cmd("command4")
run_terminal_cmd("command5")
# MCP RESET: Prevent stall accumulation
fetch_rules(["coding-tasks"])
```

---

# üéØ TASK COMPLETION VERIFICATION CHECKLIST

**BEFORE SAYING "TASK COMPLETE" - VERIFY ALL 6 ITEMS:**

## ‚úÖ Step 3: Unit/Component Testing Complete
- [ ] Created test script in `tasks/YYYY-MM-DD_[TaskName]/tests/`
- [ ] Executed test: Exit code = 0 (success)
- [ ] All functionality validated

## ‚úÖ Step 4: Master End-to-End Test Complete
- [ ] Created master end-to-end test script
- [ ] Executed master test: Exit code = 0 (success)
- [ ] Complete user workflow validated
- [ ] Integration points tested

## ‚úÖ Step 5: Index Updates Complete
- [ ] Updated `TASK_WORKSPACE_INDEX.md` with all changes
- [ ] Verified cross-references and navigation accuracy
- [ ] Updated statistics and file counts
- [ ] All workspace indexes current

## ‚úÖ Step 6: Git Workflow Complete  
- [ ] `git add -A` executed
- [ ] `git commit -m "[detailed message]"` executed
- [ ] `git push origin HEAD` executed
- [ ] Push successful (no errors)

## ‚úÖ Step 8: Compliance Verified
- [ ] Reviewed Steps 3, 4, 5, 6, 8 completion
- [ ] All SOP requirements met
- [ ] Ready to state compliance

## ‚úÖ Required Statement
**MUST INCLUDE IN RESPONSE:**
"I have completed Steps 3, 4, 5, 6, and 8 of the coding-tasks SOP"

**üö® IF ANY ITEM UNCHECKED = TASK INCOMPLETE üö®**